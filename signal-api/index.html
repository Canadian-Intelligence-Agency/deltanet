<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>δ.net Prototype: Neural Signal Stream</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for the visualization container */
        .signal-container {
            width: 100%;
            height: 60vh; /* Takes 60% of viewport height for visualization */
        }
        canvas {
            background-color: #1e293b; /* Slate-800 background */
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-100 font-sans p-6">

    <div class="max-w-4xl mx-auto space-y-6">
        <header class="text-center py-4 border-b border-indigo-500/50">
            <h1 class="text-3xl font-extrabold text-indigo-400">δ.net: Basic Protocol Stream</h1>
            <p class="text-sm text-gray-400 mt-1">Visualizing simulated 10 Hz Alpha wave data from the Go API.</p>
        </header>

        <!-- Status and Metrics Panel -->
        <div class="bg-gray-800 p-4 rounded-xl shadow-lg flex justify-between items-center text-sm">
            <div>
                <span class="text-green-400 font-bold" id="status-display">STATUS: Connecting...</span>
            </div>
            <div class="space-x-4">
                <span id="ts-display" class="text-gray-400">TS: 0 ms</span>
                <span id="freq-display" class="text-gray-400">Freq: 250 SPS</span>
                <span id="latency-display" class="text-gray-400">Latency: 0 ms</span>
            </div>
        </div>

        <!-- Canvas Container for Visualization -->
        <div class="bg-gray-800 rounded-xl shadow-xl overflow-hidden signal-container">
            <canvas id="signalCanvas"></canvas>
        </div>

        <!-- Configuration Panel (Placeholder for future controls) -->
        <div class="bg-gray-800 p-4 rounded-xl shadow-lg">
            <h3 class="text-lg font-semibold text-gray-300">Channel 1: Fp1 (Simulated)</h3>
            <p class="text-xs text-gray-500 mt-1">Simulated voltage range: 0 $\mu\text{V}$ to $100\text{\mu\text{V}}$. Core frequency: $10\text{Hz}$ Alpha.</p>
        </div>
    </div>

    <script>
        // --- Configuration ---
        const API_URL = "http://localhost:8080/api/v1/signal";
        // Interval for fetching new data (simulating a stream)
        const FETCH_INTERVAL_MS = 200; 
        // Number of data points to display in the window (e.g., 5 seconds at 250 SPS)
        const DISPLAY_POINTS = 1250; 
        
        // --- State Variables ---
        let signalBuffer = []; // Stores all recent points for plotting
        let lastFetchTime = 0; // Tracks performance
        let statusDisplay = document.getElementById('status-display');
        let tsDisplay = document.getElementById('ts-display');
        let latencyDisplay = document.getElementById('latency-display');
        
        // --- Canvas Setup ---
        const canvas = document.getElementById('signalCanvas');
        const ctx = canvas.getContext('2d');
        
        // Ensure canvas resizes with the window/container
        const resizeCanvas = () => {
            const container = document.querySelector('.signal-container');
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
        };

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // --- Data Fetching and Protocol Implementation ---
        
        // Helper function for exponential backoff retry logic
        const fetchWithRetry = async (url, attempts = 5) => {
            for (let i = 0; i < attempts; i++) {
                try {
                    const startTime = performance.now();
                    const response = await fetch(url);
                    const endTime = performance.now();
                    
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    
                    const data = await response.json();
                    
                    // Update latency metric
                    latencyDisplay.textContent = `Latency: ${Math.round(endTime - startTime)} ms`;
                    
                    return data;
                } catch (error) {
                    if (i < attempts - 1) {
                        const delay = Math.pow(2, i) * 1000;
                        console.warn(`Fetch failed. Retrying in ${delay}ms... (${error.message})`);
                        statusDisplay.textContent = `STATUS: Retrying in ${delay/1000}s...`;
                        await new Promise(res => setTimeout(res, delay));
                    } else {
                        throw error;
                    }
                }
            }
        };

        async function fetchSignalData() {
            try {
                const newPoints = await fetchWithRetry(API_URL);
                statusDisplay.classList.remove('text-red-400', 'text-yellow-400');
                statusDisplay.classList.add('text-green-400');
                statusDisplay.textContent = 'STATUS: Streaming';

                if (newPoints && newPoints.length > 0) {
                    // 1. Append new data to the buffer
                    signalBuffer.push(...newPoints);

                    // 2. Trim the buffer to maintain the display window size
                    if (signalBuffer.length > DISPLAY_POINTS) {
                        signalBuffer = signalBuffer.slice(signalBuffer.length - DISPLAY_POINTS);
                    }
                    
                    // 3. Update the latest timestamp display
                    const latestTS = signalBuffer[signalBuffer.length - 1].Timestamp;
                    tsDisplay.textContent = `TS: ${latestTS} ms`;

                    // 4. Trigger drawing
                    drawSignal();
                }
            } catch (error) {
                console.error("Critical API error:", error);
                statusDisplay.classList.remove('text-green-400');
                statusDisplay.classList.add('text-red-400');
                statusDisplay.textContent = 'STATUS: ERROR - API Down';
                // Stop the interval on critical failure
                clearInterval(dataFetcher);
            }
        }

        // --- Visualization Engine ---

        function drawSignal() {
            const width = canvas.width;
            const height = canvas.height;
            
            // Clear the canvas
            ctx.clearRect(0, 0, width, height);
            
            // Draw background (already set via CSS, but good practice to clear)
            ctx.fillStyle = '#1e293b';
            ctx.fillRect(0, 0, width, height);
            
            if (signalBuffer.length === 0) return;

            // --- Normalization ---
            
            // Find max/min voltage in the current buffer to scale the plot
            // Simulated range is 0 to 100 µV + noise, so we fix the scale for stability
            const V_MIN = 0; 
            const V_MAX = 120; // Set slightly above the 100 µV max for padding
            const V_RANGE = V_MAX - V_MIN;

            ctx.beginPath();
            ctx.strokeStyle = '#6366f1'; // Indigo-500
            ctx.lineWidth = 2;
            
            // Calculate pixel position for a given voltage
            const getCanvasY = (voltage) => {
                // Normalize voltage (0 to 1)
                const normalizedV = (voltage - V_MIN) / V_RANGE; 
                // Invert Y (canvas origin is top-left) and scale to height
                return height * (1 - normalizedV); 
            }

            // Draw the line graph
            signalBuffer.forEach((point, index) => {
                const x = (index / (DISPLAY_POINTS - 1)) * width;
                const y = getCanvasY(point.Voltage);

                if (index === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            });

            ctx.stroke();

            // --- Draw Center Line (Baseline) ---
            const baselineY = getCanvasY(V_RANGE / 2 + V_MIN); // Center of 0 to 120 is 60
            ctx.strokeStyle = '#475569'; // Slate-600
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(0, baselineY);
            ctx.lineTo(width, baselineY);
            ctx.stroke();
            ctx.setLineDash([]); // Reset line dash
            
            // Draw axes text
            ctx.fillStyle = '#94a3b8'; // Slate-400
            ctx.font = '12px Inter, sans-serif';
            ctx.fillText(`${V_MAX} µV`, 5, 15);
            ctx.fillText(`${V_MIN} µV`, 5, height - 5);
        }

        // Start the signal acquisition loop
        const dataFetcher = setInterval(fetchSignalData, FETCH_INTERVAL_MS);
        
        // Initial fetch to populate the graph quickly
        fetchSignalData(); 

    </script>
</body>
</html>
