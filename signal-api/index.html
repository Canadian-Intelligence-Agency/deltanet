<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>δ.net Prototype: Neural Signal Stream (8-Channel ADC)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for the visualization container */
        .signal-container {
            width: 100%;
            height: 60vh; /* Takes 60% of viewport height for visualization */
        }
        canvas {
            background-color: #1e293b; /* Slate-800 background */
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-100 font-sans p-6">

    <div class="max-w-4xl mx-auto space-y-6">
        <header class="text-center py-4 border-b border-indigo-500/50">
            <h1 class="text-3xl font-extrabold text-indigo-400">δ.net: 8-Channel High-Speed Protocol Stream</h1>
            <p class="text-sm text-gray-400 mt-1">Targeting the 24-bit, 30kSPS ADS via ESP32 Gateway.</p>
        </header>

        <!-- Status and Metrics Panel -->
        <div class="bg-gray-800 p-4 rounded-xl shadow-lg flex justify-between items-center text-sm">
            <div>
                <span class="text-yellow-400 font-bold" id="status-display">STATUS: Connecting...</span>
            </div>
            <div class="space-x-4 flex items-center">
                <span id="channel-count-display" class="text-gray-400 bg-gray-700 px-2 py-1 rounded-md">Channels: 0</span>
                <span id="ts-display" class="text-gray-400">TS: 0 ms</span>
                <span id="freq-display" class="text-yellow-400 font-mono">SPS: 0</span>
                <span id="latency-display" class="text-gray-400">Latency: 0 ms</span>
            </div>
        </div>

        <!-- Canvas Container for Visualization -->
        <div class="bg-gray-800 rounded-xl shadow-xl overflow-hidden signal-container">
            <canvas id="signalCanvas"></canvas>
        </div>

        <!-- Channel Status Panel -->
        <div class="bg-gray-800 p-4 rounded-xl shadow-lg">
            <h3 class="text-lg font-semibold text-gray-300 mb-2">Active Channels ($\mu\text{V}$ Scale 0-120)</h3>
            <div id="channel-status-list" class="flex flex-wrap gap-4 text-xs">
                <!-- Channel indicators will be injected here -->
            </div>
        </div>
    </div>

    <script>
        // --- Configuration ---
        // CRITICAL: This URL MUST point to your Go server running on localhost:8080
        const API_URL = "http://localhost:8080/api/v1/signal"; 
        
        // Interval for fetching new data (simulating the data packet arrival)
        const FETCH_INTERVAL_MS = 200; 
        // Number of data points to display in the window (e.g., 5 seconds at 250 SPS)
        const DISPLAY_POINTS = 1250; 
        
        // Fixed voltage range for visualization consistency
        const V_MIN = 0; 
        const V_MAX = 120; // Set slightly above the 100 µV max for padding
        const V_RANGE = V_MAX - V_MIN;
        
        // Channel Visualization Mapping (Expanded for all 8 channels)
        const CHANNEL_COLORS = {
            "Fp1": '#f87171', // Red (Frontal)
            "O1": '#34d399',  // Emerald (Occipital)
            "T3": '#fb923c',  // Orange (Temporal Left)
            "C3": '#38bdf8',  // Light Blue (Central Left)
            "C4": '#f472b6',  // Pink (Central Right)
            "Pz": '#a78bfa',  // Violet (Parietal Midline)
            "Cz": '#fbbf24',  // Amber (Central Midline)
            "M1": '#94a3b8',  // Slate (Mastoid/Reference)
        };

        // --- State Variables ---
        // Stores data: { "Fp1": [{t:..., v:...}, ...], "O1": [...] }
        let channelBuffers = {}; 
        
        // DOM Elements
        const statusDisplay = document.getElementById('status-display');
        const tsDisplay = document.getElementById('ts-display');
        const freqDisplay = document.getElementById('freq-display');
        const latencyDisplay = document.getElementById('latency-display');
        const channelCountDisplay = document.getElementById('channel-count-display');
        const channelStatusList = document.getElementById('channel-status-list');
        
        // --- Canvas Setup ---
        const canvas = document.getElementById('signalCanvas');
        const ctx = canvas.getContext('2d');
        
        // Ensure canvas resizes with the window/container
        const resizeCanvas = () => {
            const container = document.querySelector('.signal-container');
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
        };

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // --- Data Fetching and Protocol Implementation ---
        
        // Helper function for exponential backoff retry logic
        const fetchWithRetry = async (url, attempts = 5) => {
            for (let i = 0; i < attempts; i++) {
                try {
                    const startTime = performance.now();
                    
                    // Fetch data from the external Go server
                    const response = await fetch(url);
                    const endTime = performance.now();
                    
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    
                    if (response.status === 204) {
                         // 204 No Content: Server is up but has no data yet (hardware pending)
                         throw new Error("Bridge reported 204 No Content (Hardware pending).");
                    }
                    
                    const data = await response.json();
                    
                    // Update latency metric
                    latencyDisplay.textContent = `Latency: ${Math.round(endTime - startTime)} ms`;
                    
                    return data;
                } catch (error) {
                    if (i < attempts - 1) {
                        const delay = Math.pow(2, i) * 1000;
                        console.warn(`Fetch failed. Retrying in ${delay}ms... (${error.message})`);
                        statusDisplay.classList.remove('text-green-400');
                        statusDisplay.classList.add('text-yellow-400');
                        statusDisplay.textContent = `STATUS: Retrying in ${delay/1000}s...`;
                        await new Promise(res => setTimeout(res, delay));
                    } else {
                        throw error;
                    }
                }
            }
        };

        /**
         * Calculates the Samples Per Second (SPS) based on the latest data packet.
         */
        function calculateSPS(channelData) {
            if (Object.keys(channelData).length === 0) return 0;
            
            // Get the data points from the first active channel
            const firstChannelId = Object.keys(channelData)[0];
            const points = channelData[firstChannelId];

            if (points.length < 2) return 0;

            // Use the last 50 points (the packet size) for reliable calculation
            const latestPoints = points.slice(-50); 
            const startTime = latestPoints[0].t;
            const endTime = latestPoints[latestPoints.length - 1].t;
            const timeDeltaMs = endTime - startTime;
            
            if (timeDeltaMs <= 0) return 0;
            
            const numSamples = latestPoints.length;
            const sps = (numSamples * 1000) / timeDeltaMs;
            
            // Round to the nearest integer for display
            return Math.round(sps);
        }
        
        /**
         * Fetches real-time multi-channel data from the Go ADS Bridge API.
         */
        async function fetchSignalData() {
            try {
                const receivedData = await fetchWithRetry(API_URL);
                
                if (!Array.isArray(receivedData) || receivedData.length === 0) {
                    throw new Error("Received empty or invalid data structure from API.");
                }

                let processedChannels = {};
                let latestTS = 0;
                let channelCount = 0;
                
                // Ensure only configured channels are processed
                receivedData.forEach(channel => {
                    // Normalize the point data keys to 'Voltage' for the drawing function
                    channel.points.forEach(point => point.Voltage = point.v); 
                    
                    const channelId = channel.channelId;
                    if (CHANNEL_COLORS[channelId]) {
                         processedChannels[channelId] = channel.points;
                    }
                });
                
                if (Object.keys(processedChannels).length === 0) {
                     // Check if data was received but none of the 8 configured IDs were present
                     throw new Error("API returned data for 0 configured channels.");
                }
                
                statusDisplay.classList.remove('text-red-400', 'text-yellow-400');
                statusDisplay.classList.add('text-green-400');
                statusDisplay.textContent = 'STATUS: Streaming (ADS Bridge Live)';

                
                for (const channelId in processedChannels) {
                    const newPoints = processedChannels[channelId];
                    
                    if (!channelBuffers[channelId]) {
                        channelBuffers[channelId] = [];
                    }
                    
                    // 1. Append new data
                    channelBuffers[channelId].push(...newPoints);

                    // 2. Trim the buffer
                    if (channelBuffers[channelId].length > DISPLAY_POINTS) {
                        channelBuffers[channelId] = channelBuffers[channelId].slice(channelBuffers[channelId].length - DISPLAY_POINTS);
                    }
                    
                    // 3. Track latest timestamp
                    if (newPoints.length > 0) {
                        latestTS = Math.max(latestTS, newPoints[newPoints.length - 1].t);
                        channelCount++;
                    }
                }
                
                // 4. Update Metrics
                const calculatedSPS = calculateSPS(channelBuffers);
                freqDisplay.textContent = `SPS: ${calculatedSPS}`;
                tsDisplay.textContent = `TS: ${latestTS} ms`;
                channelCountDisplay.textContent = `Channels: ${channelCount}`;

                // 5. Trigger drawing
                drawSignal();

            } catch (error) {
                console.error("Critical Network Error:", error);
                // Only change status to red error if it's not a temporary retry message
                if (!statusDisplay.textContent.includes('Retrying')) {
                    statusDisplay.classList.remove('text-green-400', 'text-yellow-400');
                    statusDisplay.classList.add('text-red-400');
                    statusDisplay.textContent = 'STATUS: ERROR - Bridge Offline';
                }
            }
        }

        // --- Visualization Engine ---

        function drawSignal() {
            const width = canvas.width;
            const height = canvas.height;
            
            // Clear the canvas
            ctx.clearRect(0, 0, width, height);
            
            // Draw background
            ctx.fillStyle = '#1e293b';
            ctx.fillRect(0, 0, width, height);
            
            const activeChannels = Object.keys(channelBuffers).filter(id => channelBuffers[id].length > 0);
            if (activeChannels.length === 0) return;

            // Calculate vertical segment height for each channel
            const segmentHeight = height / activeChannels.length;
            
            // Draw axes text
            ctx.fillStyle = '#94a3b8'; // Slate-400
            ctx.font = '12px Inter, sans-serif';
            ctx.fillText(`Scale: ${V_MAX} µV`, 5, 15);
            ctx.fillText(`${V_MIN} µV`, 5, height - 5);
            
            let channelIndex = 0;

            // Update channel status list HTML
            channelStatusList.innerHTML = activeChannels.map(channelId => 
                `<span class="px-2 py-1 rounded-full" style="background-color: ${CHANNEL_COLORS[channelId]}; color: #1e293b; font-weight: bold;">${channelId}</span>`
            ).join('');

            
            activeChannels.forEach((channelId) => {
                const buffer = channelBuffers[channelId];
                const color = CHANNEL_COLORS[channelId];
                
                // Define the vertical plotting area for this channel segment
                const topY = channelIndex * segmentHeight;
                const centerSegmentY = topY + (segmentHeight / 2);

                // --- Draw Segment Baseline ---
                ctx.strokeStyle = '#475569'; // Slate-600
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(0, centerSegmentY);
                ctx.lineTo(width, centerSegmentY);
                ctx.stroke();
                
                // Draw channel label inside the segment
                ctx.fillStyle = color;
                ctx.fillText(channelId, 10, topY + 15);
                ctx.setLineDash([]); // Reset line dash

                // --- Draw Signal ---

                ctx.beginPath();
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                
                // Calculate pixel position for a given voltage
                const getCanvasY = (voltage) => {
                    // Normalize voltage (0 to 1) relative to the fixed V_RANGE
                    const normalizedV = (voltage - V_MIN) / V_RANGE; 
                    
                    // Scale the signal vertically within its segment
                    // Use 80% of segmentHeight for the signal, centered on segment
                    const signalRange = segmentHeight * 0.8;
                    const signalOffset = segmentHeight * 0.1; // 10% padding top/bottom

                    // Invert Y (1 - normalizedV) and scale to signal range
                    const yInSegment = topY + signalOffset + (1 - normalizedV) * signalRange;
                    
                    return yInSegment;
                }

                // Draw the line graph
                buffer.forEach((point, index) => {
                    // X position across the full canvas width
                    const x = (index / (DISPLAY_POINTS - 1)) * width;
                    const y = getCanvasY(point.Voltage);

                    if (index === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });

                ctx.stroke();

                channelIndex++;
            });
        }

        // Start the signal acquisition loop
        const dataFetcher = setInterval(fetchSignalData, FETCH_INTERVAL_MS);
        
        // Initial fetch to populate the graph quickly
        fetchSignalData(); 

    </script>
</body>
</html>
