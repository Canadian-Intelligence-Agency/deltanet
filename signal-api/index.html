<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>δ.net Prototype: Neural Signal Stream (Self-Contained)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for the visualization container */
        .signal-container {
            width: 100%;
            height: 60vh; /* Takes 60% of viewport height for visualization */
        }
        canvas {
            background-color: #1e293b; /* Slate-800 background */
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-100 font-sans p-6">

    <div class="max-w-4xl mx-auto space-y-6">
        <header class="text-center py-4 border-b border-indigo-500/50">
            <h1 class="text-3xl font-extrabold text-indigo-400">δ.net: Multi-Channel Protocol Stream</h1>
            <p class="text-sm text-gray-400 mt-1">Simulated EEG Data (Wasm/In-Browser Model) - No external API required.</p>
        </header>

        <!-- Status and Metrics Panel -->
        <div class="bg-gray-800 p-4 rounded-xl shadow-lg flex justify-between items-center text-sm">
            <div>
                <span class="text-green-400 font-bold" id="status-display">STATUS: Connecting...</span>
            </div>
            <div class="space-x-4 flex items-center">
                <span id="channel-count-display" class="text-gray-400 bg-gray-700 px-2 py-1 rounded-md">Channels: 0</span>
                <span id="ts-display" class="text-gray-400">TS: 0 ms</span>
                <span id="freq-display" class="text-yellow-400 font-mono">SPS: 0</span>
            </div>
        </div>

        <!-- Canvas Container for Visualization -->
        <div class="bg-gray-800 rounded-xl shadow-xl overflow-hidden signal-container">
            <canvas id="signalCanvas"></canvas>
        </div>

        <!-- Channel Status Panel -->
        <div class="bg-gray-800 p-4 rounded-xl shadow-lg">
            <h3 class="text-lg font-semibold text-gray-300 mb-2">Active Channels ($\mu\text{V}$ Scale 0-120)</h3>
            <div id="channel-status-list" class="flex flex-wrap gap-4 text-xs">
                <!-- Channel indicators will be injected here -->
            </div>
        </div>
    </div>

    <script>
        // --- Configuration ---
        // Removed API_URL and latency tracking as the app is now self-contained.
        // Interval for generating new data (simulating the data packet arrival)
        const FETCH_INTERVAL_MS = 200; 
        // Number of data points to display in the window (e.g., 5 seconds at 250 SPS)
        const DISPLAY_POINTS = 1250; 
        
        // Fixed voltage range for visualization consistency
        const V_MIN = 0; 
        const V_MAX = 120; // Set slightly above the 100 µV max for padding
        const V_RANGE = V_MAX - V_MIN;
        
        // Channel Visualization Mapping
        const CHANNEL_COLORS = {
            "Fp1": '#6366f1', // Indigo (Alpha, Frontal)
            "O1": '#22c55e',  // Green (Theta/Visual, Occipital)
            "T3": '#f97316',  // Orange (Gamma/High Freq, Temporal)
        };
        const MAX_CHANNELS = 3; // Max channels to visualize

        // --- State Variables ---
        // Stores data: { "Fp1": [{t:..., v:...}, ...], "O1": [...] }
        let channelBuffers = {}; 
        let timeIndex = 0; // Represents time in seconds for sine wave generation
        
        // DOM Elements
        const statusDisplay = document.getElementById('status-display');
        const tsDisplay = document.getElementById('ts-display');
        const freqDisplay = document.getElementById('freq-display');
        const channelCountDisplay = document.getElementById('channel-count-display');
        const channelStatusList = document.getElementById('channel-status-list');
        
        // --- Canvas Setup ---
        const canvas = document.getElementById('signalCanvas');
        const ctx = canvas.getContext('2d');
        
        // Ensure canvas resizes with the window/container
        const resizeCanvas = () => {
            const container = document.querySelector('.signal-container');
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
        };

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // --- Data Generation (Go Wasm Replacement) ---

        /**
         * Simulates a burst of multi-channel EEG data.
         * @param {number} numPoints The number of samples to generate.
         * @returns {Array<{channelId: string, points: Array<{t: number, v: number}>}>}
         */
        function generateSimulatedEEGData(numPoints) {
            // Simulation Constants
            const samplingRate = 250.0;  // Samples per second (SPS)
            const timeStep = 1.0 / samplingRate;
            const initialTimestampMs = performance.now(); // Base timestamp for this batch

            const data = [
                { channelId: "Fp1", points: [] },
                { channelId: "O1", points: [] },
                { channelId: "T3", points: [] },
            ];

            for (let i = 0; i < numPoints; i++) {
                const currentSimTime = timeIndex;
                const currentTimeMs = initialTimestampMs + (i * 1000 / samplingRate);

                // Fp1 (Alpha + Low Frequency Component)
                const v_fp1 = 50 * Math.sin(2 * Math.PI * 10.0 * currentSimTime) + // 10 Hz Alpha
                              20 * Math.sin(2 * Math.PI * 2.0 * currentSimTime) +   // 2 Hz Slow Wave/Drift
                              50.0 + (Math.random() * 10 - 5);                     // DC Offset + Random Noise 

                // O1 (Theta + Visual Artifacts)
                const v_o1 = 30 * Math.sin(2 * Math.PI * 4.0 * currentSimTime) +  // 4 Hz Theta Rhythm
                             40.0 + (Math.random() * 8 - 4);                      // DC Offset + Random Noise

                // T3 (Gamma Burst - High Frequency/Low Amplitude)
                const v_t3 = 10 * Math.sin(2 * Math.PI * 30.0 * currentSimTime) + // 30 Hz Gamma Rhythm
                             20.0 + (Math.random() * 15 - 7.5);                    // DC Offset + Higher Noise

                data[0].points.push({ t: Math.round(currentTimeMs), v: Math.max(0, v_fp1) });
                data[1].points.push({ t: Math.round(currentTimeMs), v: Math.max(0, v_o1) });
                data[2].points.push({ t: Math.round(currentTimeMs), v: Math.max(0, v_t3) });

                timeIndex += timeStep;
            }

            return data;
        }

        /**
         * Calculates the Samples Per Second (SPS) based on the latest data packet.
         */
        function calculateSPS(channelData) {
            if (Object.keys(channelData).length === 0) return 0;
            
            // Get the data points from the first channel
            const firstChannelId = Object.keys(channelData)[0];
            const points = channelData[firstChannelId];

            if (points.length < 2) return 0;

            const latestPoints = points.slice(-50); // Use the last 50 points for reliable calculation
            const startTime = latestPoints[0].t;
            const endTime = latestPoints[latestPoints.length - 1].t;
            const timeDeltaMs = endTime - startTime;
            
            if (timeDeltaMs <= 0) return 0;
            
            const numSamples = latestPoints.length;
            const sps = (numSamples * 1000) / timeDeltaMs;
            
            return Math.round(sps);
        }
        
        /**
         * Generates and processes multi-channel data.
         */
        async function generateAndProcessData() {
            try {
                // --- Data Generation ---
                let processedChannels = {};
                const pointsToGenerate = 50;
                const newBatchData = generateSimulatedEEGData(pointsToGenerate);
                
                // --- Processing Logic ---
                newBatchData.forEach(channel => {
                    if (CHANNEL_COLORS[channel.channelId]) {
                         processedChannels[channel.channelId] = channel.points;
                    }
                });
                
                if (Object.keys(processedChannels).length === 0) {
                     throw new Error("No recognized channel data found.");
                }
                
                statusDisplay.classList.remove('text-red-400', 'text-yellow-400');
                statusDisplay.classList.add('text-green-400');
                statusDisplay.textContent = 'STATUS: Streaming (Self-Contained)';

                let latestTS = 0;
                let channelCount = 0;
                
                for (const channelId in processedChannels) {
                    const newPoints = processedChannels[channelId];
                    
                    if (!channelBuffers[channelId]) {
                        channelBuffers[channelId] = [];
                    }
                    
                    // 1. Append new data
                    channelBuffers[channelId].push(...newPoints);

                    // 2. Trim the buffer
                    if (channelBuffers[channelId].length > DISPLAY_POINTS) {
                        channelBuffers[channelId] = channelBuffers[channelId].slice(channelBuffers[channelId].length - DISPLAY_POINTS);
                    }
                    
                    // 3. Track latest timestamp
                    if (newPoints.length > 0) {
                        latestTS = Math.max(latestTS, newPoints[newPoints.length - 1].t);
                        channelCount++;
                    }
                }
                
                // 4. Update Metrics
                const calculatedSPS = calculateSPS(channelBuffers);
                freqDisplay.textContent = `SPS: ${calculatedSPS}`;
                tsDisplay.textContent = `TS: ${latestTS} ms`;
                channelCountDisplay.textContent = `Channels: ${channelCount}`;

                // 5. Trigger drawing
                drawSignal();

            } catch (error) {
                // Since this is a local simulation, a catch here indicates a logic error, not a network failure.
                console.error("Critical Simulation Error:", error);
                statusDisplay.classList.remove('text-green-400');
                statusDisplay.classList.add('text-red-400');
                statusDisplay.textContent = 'STATUS: ERROR - Simulation Failure';
                // Stop the interval on critical failure
                clearInterval(dataFetcher);
            }
        }

        // --- Visualization Engine ---

        function drawSignal() {
            const width = canvas.width;
            const height = canvas.height;
            
            // Clear the canvas
            ctx.clearRect(0, 0, width, height);
            
            // Draw background
            ctx.fillStyle = '#1e293b';
            ctx.fillRect(0, 0, width, height);
            
            const activeChannels = Object.keys(channelBuffers).filter(id => channelBuffers[id].length > 0);
            if (activeChannels.length === 0) return;

            // Calculate vertical segment height for each channel
            const segmentHeight = height / activeChannels.length;
            
            // Draw axes text
            ctx.fillStyle = '#94a3b8'; // Slate-400
            ctx.font = '12px Inter, sans-serif';
            ctx.fillText(`Scale: ${V_MAX} µV`, 5, 15);
            ctx.fillText(`${V_MIN} µV`, 5, height - 5);
            
            let channelIndex = 0;

            // Update channel status list HTML
            channelStatusList.innerHTML = activeChannels.map(channelId => 
                `<span class="px-2 py-1 rounded-full" style="background-color: ${CHANNEL_COLORS[channelId]}; color: #1e293b; font-weight: bold;">${channelId}</span>`
            ).join('');

            
            activeChannels.forEach((channelId) => {
                const buffer = channelBuffers[channelId];
                const color = CHANNEL_COLORS[channelId];
                
                // Define the vertical plotting area for this channel segment
                const topY = channelIndex * segmentHeight;
                const centerSegmentY = topY + (segmentHeight / 2);

                // --- Draw Segment Baseline ---
                ctx.strokeStyle = '#475569'; // Slate-600
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(0, centerSegmentY);
                ctx.lineTo(width, centerSegmentY);
                ctx.stroke();
                
                // Draw channel label inside the segment
                ctx.fillStyle = color;
                ctx.fillText(channelId, 10, topY + 15);
                ctx.setLineDash([]); // Reset line dash

                // --- Draw Signal ---

                ctx.beginPath();
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                
                // Calculate pixel position for a given voltage
                const getCanvasY = (voltage) => {
                    // Normalize voltage (0 to 1) relative to the fixed V_RANGE
                    const normalizedV = (voltage - V_MIN) / V_RANGE; 
                    
                    // Scale the signal vertically within its segment
                    // Use 80% of segmentHeight for the signal, centered on segment
                    const signalRange = segmentHeight * 0.8;
                    const signalOffset = segmentHeight * 0.1; // 10% padding top/bottom

                    // Invert Y (1 - normalizedV) and scale to signal range
                    const yInSegment = topY + signalOffset + (1 - normalizedV) * signalRange;
                    
                    return yInSegment;
                }

                // Draw the line graph
                buffer.forEach((point, index) => {
                    // X position across the full canvas width
                    const x = (index / (DISPLAY_POINTS - 1)) * width;
                    const y = getCanvasY(point.Voltage);

                    if (index === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });

                ctx.stroke();

                channelIndex++;
            });
        }

        // Start the signal acquisition loop
        const dataFetcher = setInterval(generateAndProcessData, FETCH_INTERVAL_MS);
        
        // Initial fetch to populate the graph quickly
        generateAndProcessData(); 

    </script>
</body>
</html>
