<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>δ.net Prototype: Neural Signal Stream</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for the visualization container */
        .signal-container {
            width: 100%;
            height: 60vh; /* Takes 60% of viewport height for visualization */
        }
        canvas {
            background-color: #1e293b; /* Slate-800 background */
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-100 font-sans p-6">

    <div class="max-w-4xl mx-auto space-y-6">
        <header class="text-center py-4 border-b border-indigo-500/50">
            <h1 class="text-3xl font-extrabold text-indigo-400">δ.net: Multi-Channel Protocol Stream</h1>
            <p class="text-sm text-gray-400 mt-1">Visualizing simulated 10 Hz Alpha, 4 Hz Theta, and Gamma wave data from the Go API.</p>
        </header>

        <!-- Status and Metrics Panel -->
        <div class="bg-gray-800 p-4 rounded-xl shadow-lg flex justify-between items-center text-sm">
            <div>
                <span class="text-green-400 font-bold" id="status-display">STATUS: Connecting...</span>
            </div>
            <div class="space-x-4 flex items-center">
                <span id="channel-count-display" class="text-gray-400 bg-gray-700 px-2 py-1 rounded-md">Channels: 0</span>
                <span id="ts-display" class="text-gray-400">TS: 0 ms</span>
                <span id="freq-display" class="text-yellow-400 font-mono">SPS: 0</span>
                <span id="latency-display" class="text-gray-400">Latency: 0 ms</span>
            </div>
        </div>

        <!-- Canvas Container for Visualization -->
        <div class="bg-gray-800 rounded-xl shadow-xl overflow-hidden signal-container">
            <canvas id="signalCanvas"></canvas>
        </div>

        <!-- Channel Status Panel -->
        <div class="bg-gray-800 p-4 rounded-xl shadow-lg">
            <h3 class="text-lg font-semibold text-gray-300 mb-2">Active Channels ($\mu\text{V}$ Scale 0-120)</h3>
            <div id="channel-status-list" class="flex flex-wrap gap-4 text-xs">
                <!-- Channel indicators will be injected here -->
            </div>
        </div>
    </div>

    <script>
        // --- Configuration ---
        const API_URL = "http://localhost:8080/api/v1/signal"; // Assuming Go server will now return multi-channel data
        // Interval for fetching new data (simulating a stream)
        const FETCH_INTERVAL_MS = 200; 
        // Number of data points to display in the window (e.g., 5 seconds at 250 SPS)
        const DISPLAY_POINTS = 1250; 
        
        // Fixed voltage range for visualization consistency
        const V_MIN = 0; 
        const V_MAX = 120; // Set slightly above the 100 µV max for padding
        const V_RANGE = V_MAX - V_MIN;
        
        // Channel Visualization Mapping
        const CHANNEL_COLORS = {
            "Fp1": '#6366f1', // Indigo (Alpha, Frontal)
            "O1": '#22c55e',  // Green (Theta/Visual, Occipital)
            "T3": '#f97316',  // Orange (Gamma/High Freq, Temporal)
        };
        const MAX_CHANNELS = 3; // Max channels to visualize

        // --- State Variables ---
        // Stores data: { "Fp1": [{t:..., v:...}, ...], "O1": [...] }
        let channelBuffers = {}; 
        let lastTimestamp = 0; // For SPS calculation
        
        // DOM Elements
        const statusDisplay = document.getElementById('status-display');
        const tsDisplay = document.getElementById('ts-display');
        const freqDisplay = document.getElementById('freq-display');
        const latencyDisplay = document.getElementById('latency-display');
        const channelCountDisplay = document.getElementById('channel-count-display');
        const channelStatusList = document.getElementById('channel-status-list');
        
        // --- Canvas Setup ---
        const canvas = document.getElementById('signalCanvas');
        const ctx = canvas.getContext('2d');
        
        // Ensure canvas resizes with the window/container
        const resizeCanvas = () => {
            const container = document.querySelector('.signal-container');
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
        };

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // --- Data Fetching and Protocol Implementation ---
        
        // Helper function for exponential backoff retry logic
        const fetchWithRetry = async (url, attempts = 5) => {
            for (let i = 0; i < attempts; i++) {
                try {
                    const startTime = performance.now();
                    const response = await fetch(url);
                    const endTime = performance.now();
                    
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    
                    const data = await response.json();
                    
                    // Update latency metric
                    latencyDisplay.textContent = `Latency: ${Math.round(endTime - startTime)} ms`;
                    
                    return data;
                } catch (error) {
                    if (i < attempts - 1) {
                        const delay = Math.pow(2, i) * 1000;
                        console.warn(`Fetch failed. Retrying in ${delay}ms... (${error.message})`);
                        statusDisplay.textContent = `STATUS: Retrying in ${delay/1000}s...`;
                        await new Promise(res => setTimeout(res, delay));
                    } else {
                        throw error;
                    }
                }
            }
        };

        /**
         * Calculates the Samples Per Second (SPS) based on the latest data packet.
         * Assumes the first channel in the buffer is representative.
         */
        function calculateSPS(channelData) {
            if (Object.keys(channelData).length === 0) return 0;
            
            // Get the data points from the first channel
            const firstChannelId = Object.keys(channelData)[0];
            const points = channelData[firstChannelId];

            if (points.length < 2) return 0;

            const latestPoints = points.slice(-50); // Use the last 50 points for reliable calculation
            const startTime = latestPoints[0].t;
            const endTime = latestPoints[latestPoints.length - 1].t;
            const timeDeltaMs = endTime - startTime;
            
            if (timeDeltaMs <= 0) return 0;
            
            const numSamples = latestPoints.length;
            const sps = (numSamples * 1000) / timeDeltaMs;
            
            return Math.round(sps);
        }
        
        /**
         * Processes incoming multi-channel data and updates buffers.
         * Note: The Go server needs to be updated to return this structure.
         * Expected format: [{ channelId: "Fp1", points: [{t:..., v:...}, ...] }, ...]
         */
        async function fetchSignalData() {
            try {
                // Fetch the new data array (expected multi-channel payload)
                // If the Go server is still returning a single array of points, 
                // this code will wrap it into a simulated multi-channel format for plotting.
                let receivedData = await fetchWithRetry(API_URL);
                
                // --- Multi-Channel Adaptation/Simulation ---
                let processedChannels = {};
                
                if (!Array.isArray(receivedData) || receivedData.length === 0) {
                    throw new Error("Invalid data format received.");
                }

                if (receivedData[0].channelId === undefined) {
                    // Simulate multi-channel data if the Go server returns only one channel (legacy)
                    const simulatedPoints = receivedData; 
                    
                    // For visualization testing, we'll create simulated data for O1 and T3 based on Fp1
                    const generateSimulatedChannel = (basePoints, offsetFactor, noiseFactor) => {
                        return basePoints.map(p => ({
                            t: p.t,
                            // Apply a voltage offset and different noise/amplitude profile
                            v: Math.max(0, p.v + offsetFactor + (Math.random() * noiseFactor)) 
                        }));
                    };

                    processedChannels["Fp1"] = simulatedPoints;
                    processedChannels["O1"] = generateSimulatedChannel(simulatedPoints, -10, 5);
                    processedChannels["T3"] = generateSimulatedChannel(simulatedPoints, 20, 15);

                } else {
                    // Use the true multi-channel data structure from the updated Go server
                    receivedData.forEach(channel => {
                        if (CHANNEL_COLORS[channel.channelId]) {
                             processedChannels[channel.channelId] = channel.points;
                        }
                    });
                }
                
                if (Object.keys(processedChannels).length === 0) {
                     throw new Error("No recognized channel data found.");
                }
                
                statusDisplay.classList.remove('text-red-400', 'text-yellow-400');
                statusDisplay.classList.add('text-green-400');
                statusDisplay.textContent = 'STATUS: Streaming';

                let latestTS = 0;
                let channelCount = 0;
                
                for (const channelId in processedChannels) {
                    const newPoints = processedChannels[channelId];
                    
                    if (!channelBuffers[channelId]) {
                        channelBuffers[channelId] = [];
                    }
                    
                    // 1. Append new data
                    channelBuffers[channelId].push(...newPoints);

                    // 2. Trim the buffer
                    if (channelBuffers[channelId].length > DISPLAY_POINTS) {
                        channelBuffers[channelId] = channelBuffers[channelId].slice(channelBuffers[channelId].length - DISPLAY_POINTS);
                    }
                    
                    // 3. Track latest timestamp
                    if (newPoints.length > 0) {
                        latestTS = Math.max(latestTS, newPoints[newPoints.length - 1].t);
                        channelCount++;
                    }
                }
                
                // 4. Update Metrics
                const calculatedSPS = calculateSPS(channelBuffers);
                freqDisplay.textContent = `SPS: ${calculatedSPS}`;
                tsDisplay.textContent = `TS: ${latestTS} ms`;
                channelCountDisplay.textContent = `Channels: ${channelCount}`;

                // 5. Trigger drawing
                drawSignal();

            } catch (error) {
                console.error("Critical API error:", error);
                statusDisplay.classList.remove('text-green-400');
                statusDisplay.classList.add('text-red-400');
                statusDisplay.textContent = 'STATUS: ERROR - API Down';
                // Stop the interval on critical failure
                clearInterval(dataFetcher);
            }
        }

        // --- Visualization Engine ---

        function drawSignal() {
            const width = canvas.width;
            const height = canvas.height;
            
            // Clear the canvas
            ctx.clearRect(0, 0, width, height);
            
            // Draw background
            ctx.fillStyle = '#1e293b';
            ctx.fillRect(0, 0, width, height);
            
            const activeChannels = Object.keys(channelBuffers).filter(id => channelBuffers[id].length > 0);
            if (activeChannels.length === 0) return;

            // Calculate vertical segment height for each channel
            const segmentHeight = height / activeChannels.length;
            
            // Draw axes text
            ctx.fillStyle = '#94a3b8'; // Slate-400
            ctx.font = '12px Inter, sans-serif';
            ctx.fillText(`Scale: ${V_MAX} µV`, 5, 15);
            ctx.fillText(`${V_MIN} µV`, 5, height - 5);
            
            let channelIndex = 0;

            // Update channel status list HTML
            channelStatusList.innerHTML = activeChannels.map(channelId => 
                `<span class="px-2 py-1 rounded-full" style="background-color: ${CHANNEL_COLORS[channelId]}; color: #1e293b; font-weight: bold;">${channelId}</span>`
            ).join('');

            
            activeChannels.forEach((channelId) => {
                const buffer = channelBuffers[channelId];
                const color = CHANNEL_COLORS[channelId];
                
                // Define the vertical plotting area for this channel segment
                const topY = channelIndex * segmentHeight;
                const centerSegmentY = topY + (segmentHeight / 2);

                // --- Draw Segment Baseline ---
                ctx.strokeStyle = '#475569'; // Slate-600
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(0, centerSegmentY);
                ctx.lineTo(width, centerSegmentY);
                ctx.stroke();
                
                // Draw channel label inside the segment
                ctx.fillStyle = color;
                ctx.fillText(channelId, 10, topY + 15);
                ctx.setLineDash([]); // Reset line dash

                // --- Draw Signal ---

                ctx.beginPath();
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                
                // Calculate pixel position for a given voltage
                const getCanvasY = (voltage) => {
                    // Normalize voltage (0 to 1) relative to the fixed V_RANGE
                    const normalizedV = (voltage - V_MIN) / V_RANGE; 
                    
                    // Scale the signal vertically within its segment
                    // Use 80% of segmentHeight for the signal, centered on segment
                    const signalRange = segmentHeight * 0.8;
                    const signalOffset = segmentHeight * 0.1; // 10% padding top/bottom

                    // Invert Y (1 - normalizedV) and scale to signal range
                    const yInSegment = topY + signalOffset + (1 - normalizedV) * signalRange;
                    
                    return yInSegment;
                }

                // Draw the line graph
                buffer.forEach((point, index) => {
                    // X position across the full canvas width
                    const x = (index / (DISPLAY_POINTS - 1)) * width;
                    const y = getCanvasY(point.Voltage);

                    if (index === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });

                ctx.stroke();

                channelIndex++;
            });
        }

        // Start the signal acquisition loop
        const dataFetcher = setInterval(fetchSignalData, FETCH_INTERVAL_MS);
        
        // Initial fetch to populate the graph quickly
        fetchSignalData(); 

    </script>
</body>
</html>
